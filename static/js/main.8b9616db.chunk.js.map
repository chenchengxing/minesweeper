{"version":3,"sources":["types/Cell.ts","comps/Cell.tsx","utils/get-cell-display-content.ts","comps/Board.tsx","constants/BoardDimensions.ts","hooks/useContextMenu.ts","utils/rearrange-cells.ts","comps/BoardContainer.tsx","utils/get-surrounding-cell-indexes.ts","types/GameStatus.ts","utils/spread-mines.ts","utils/uncover-all-safe-cells.ts","utils/check-game-win.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["CellStatus","isCellCovered","cell","status","Covered","isCellFlagged","Flagged","CellComp","props","onClick","data-testid","className","cn","Uncovered","isMine","numOfMinesAround","getCellDisplayContent","BoardComp","cells","onCellRightClick","onCellClick","numOfCols","numOfRows","ref","useRef","refEl","callback","savedHandler","useEffect","current","element","addEventListener","eventListener","event","removeEventListener","useContextMenuEvent","useCallback","e","preventDefault","elementRect","currentTarget","getBoundingClientRect","relativeX","clientX","left","relativeY","clientY","top","rowIndex","Math","floor","colIndex","handleClick","rearrangedCells","length","originalIndex","result","currentRow","push","rearrangeCells","map","cellRow","key","Cell","index","BoardContainerComp","Board","getSurroundingCellIndexes","params","mineIndex","row","col","len","hasTop","topIndex","hasLeft","hasRight","hasBottom","bottomIndex","GameStatus","hasTopLeft","hasTopRight","hasBottomLeft","hasBottomRight","increaseMineCountForSurroundingCells","surroundingCellIndexes","slice","includes","added","dfsVisit","currentCell","stack","hasDirectionFunction","getIndex","forEach","visitingIndex","visited","checkGameWin","isEveryMineFlagged","filter","every","isEveryNonMineUncovered","App","useState","setCells","PLAYING","gameStatus","setGameStatus","initialCells","BOARD_COLUMNS","gameReset","numOfMines","generatedCount","generatedHash","r","random","spreadMines","LOST","WIN","BoardContainer","targetCell","upcomingCells","originCell","cellsWithVisited","splice","uncoverAllSafeCells","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.8b9616db.chunk.js","sourcesContent":["export interface Cell {\n  index: number,\n  status: CellStatus,\n  isMine: boolean,\n  numOfMinesAround: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8,\n}\n\nexport enum CellStatus {\n  Covered,\n  Uncovered,\n  Flagged,\n}\n\nexport const isCellCovered = (cell: Cell) => cell.status === CellStatus.Covered\nexport const isCellUncovered = (cell: Cell) => cell.status === CellStatus.Uncovered\nexport const isCellFlagged = (cell: Cell) => cell.status === CellStatus.Flagged","import React from 'react'\nimport { Cell, CellStatus } from '../types/Cell'\nimport cn from 'classnames'\nimport { getCellDisplayContent } from '../utils/get-cell-display-content'\n\ninterface Props {\n  cell: Cell,\n  onClick(e: React.MouseEvent<HTMLElement, MouseEvent>): void,\n}\n\nfunction CellComp(props: Props) {\n  const {\n    cell,\n    onClick,\n  } = props\n  const { status } = cell\n  return (\n    <div \n      data-testid='cell'\n      className={\n        cn('cell', {\n          'cell-covered': status === CellStatus.Covered,\n          'cell-uncovered': status === CellStatus.Uncovered,\n          'cell-flagged': status === CellStatus.Flagged,\n        })\n      }\n      onClick={onClick}\n    >\n      { getCellDisplayContent(cell) }\n    </div>\n  )\n}\n\nexport default CellComp\n","import { Cell, CellStatus } from '../types/Cell'\n\nexport function getCellDisplayContent(cell: Cell) {\n  const { status } = cell\n  switch(status) {\n    case CellStatus.Covered:\n      return null\n    case CellStatus.Flagged:\n      return null\n    case CellStatus.Uncovered: {\n      if (cell.isMine) {\n        return `*`\n      } else {\n        if (cell.numOfMinesAround === 0) {\n          return null\n        } else {\n          return cell.numOfMinesAround\n        }\n      }\n    }\n  }\n}","import React, { SyntheticEvent, useCallback, useRef } from 'react'\nimport { BOARD_COLUMNS, BOARD_ROWS, CELL_SIZE } from '../constants/BoardDimensions'\nimport { useContextMenuEvent } from '../hooks/useContextMenu'\nimport { Cell } from '../types/Cell'\nimport { rearrangeCells } from '../utils/rearrange-cells'\nimport CellComp from './Cell'\n\nexport interface BoardCompProps {\n  cells: Cell[],\n  onCellRightClick(index: number): void,\n  onCellClick(index: number): void,\n  numOfCols?: number,\n  numOfRows?: number,\n}\nfunction BoardComp(props: BoardCompProps) {\n  const {\n    cells,\n    onCellRightClick,\n    onCellClick,\n    numOfCols = BOARD_COLUMNS,\n    numOfRows = BOARD_ROWS,\n  } = props\n\n  const ref = useRef(null)\n  \n  const handleRightClick = useCallback((e: MouseEvent) => {\n    e.preventDefault()\n    const elementRect = (e.currentTarget as HTMLElement).getBoundingClientRect()\n    const relativeX = e.clientX - elementRect.left\n    const relativeY = e.clientY - elementRect.top\n    const rowIndex = Math.floor(relativeY / CELL_SIZE)\n    const colIndex = Math.floor(relativeX / CELL_SIZE)\n    // console.log(relativeX, relativeY, rowIndex, colIndex)\n    onCellRightClick(rowIndex * numOfCols + colIndex)\n  }, [onCellRightClick])\n\n  useContextMenuEvent(ref, handleRightClick)\n\n  const handleClick = (rowIndex: number, colIndex: number) => () => {\n    onCellClick(rowIndex * numOfCols + colIndex)\n  }\n\n  const rearrangedCells: Cell[][] = rearrangeCells(cells, numOfRows, numOfCols)\n  return (\n    <div ref={ref}>\n      {\n        rearrangedCells.map((cellRow: Cell[], rowIndex: number) => {\n          return (\n            <div key={rowIndex} className={'cell-row'}>\n              {\n                cellRow.map((cell: Cell, colIndex: number) => {\n                  return (\n                    <CellComp \n                      key={cell.index} \n                      cell={cell}\n                      onClick={handleClick(rowIndex, colIndex)}\n                    />\n                  )\n                })\n              }\n            </div>\n          )\n        })\n      }\n    </div>\n  )\n}\n\nexport default BoardComp\n","export const BOARD_COLUMNS = 10\nexport const BOARD_ROWS = 8\nexport const NUMBER_OF_MINES = 10\nexport const CELL_SIZE = 30 + 2 // 2px for border","import { RefObject, useEffect, useRef, useState } from 'react'\n\nexport function useContextMenuEvent(refEl: RefObject<HTMLElement>, callback: (e: MouseEvent) => void ) {\n  const savedHandler = useRef<typeof callback>()\n  \n  useEffect(() => {\n    savedHandler.current = callback\n  }, [callback])\n\n  useEffect(() => {\n    const element = refEl.current\n    if (!(element && element.addEventListener)) {\n      return\n    }\n    \n    const eventListener = (event: MouseEvent) => savedHandler.current!(event)\n    element.addEventListener('contextmenu', eventListener)\n    return () => {\n      element.removeEventListener('contextmenu', eventListener)\n    }\n  }, [])\n}","import { Cell } from '../types/Cell'\n\nexport function rearrangeCells(cells: Cell[], numOfRows: number, numOfCols: number) {\n  if (cells.length !== numOfCols * numOfRows) {\n    return []\n  }\n  let originalIndex = 0\n  let result: Cell[][] = []\n  for (let rowIndex = 0; rowIndex < numOfRows; rowIndex++) {\n    let currentRow: Cell[] = []\n    for (let colIndex = 0; colIndex < numOfCols; colIndex++) {\n      currentRow.push(cells[originalIndex])\n      originalIndex += 1\n    }\n    result.push(currentRow)\n  }\n  return result\n}","import React from 'react'\nimport { Cell } from '../types/Cell'\nimport BoardComp, { BoardCompProps } from './Board'\n\ninterface Props {\n  cells: Cell[],\n  onCellRightClick(index: number, cells: Cell[]): void,\n  onCellClick(index: number): void,\n}\n\nfunction BoardContainerComp(props: BoardCompProps) {\n  const {\n    cells,\n  } = props\n\n  if (!cells.length) {\n    return null\n  }\n  \n  return <BoardComp {...props} />\n}\n\nexport default BoardContainerComp\n","import { Cell } from '../types/Cell'\n\ninterface Params {\n  cells: Cell[],\n  mineIndex: number,\n  numOfRows: number, \n  numOfCols: number,\n}\n\nexport function getSurroundingCellIndexes(params: Params): number[] {\n  const {\n    cells,\n    mineIndex: index,\n    numOfRows: row,\n    numOfCols: col,\n  } = params\n  const len = cells.length\n\n  const result: number[] = []\n  \n  if (hasTop(index, len, row, col)) {\n    const topIndex = index - col\n    result.push(topIndex)\n    if (hasLeft(topIndex, len, row, col)) {\n      result.push(topIndex - 1)\n    }\n    if (hasRight(topIndex, len, row, col)) {\n      result.push(topIndex + 1)\n    }\n  }\n  if (hasLeft(index, len, row, col)) {\n    result.push(index - 1)\n  }\n  if (hasRight(index, len, row, col)) {\n    result.push(index + 1)\n  }\n  if (hasBottom(index, len, row, col)) {\n    const bottomIndex = index + col\n    result.push(bottomIndex)\n    if (hasLeft(bottomIndex, len, row, col)) {\n      result.push(bottomIndex - 1)\n    }\n    if (hasRight(bottomIndex, len, row, col)) {\n      result.push(bottomIndex + 1)\n    }\n  }\n  \n  return result\n}\n\nexport const hasTop = (index: number, len: number, row: number, col: number) => {\n  return !(index < col)\n}\nexport const hasBottom = (index: number, len: number, row: number, col: number) => {\n  return !(index >= (row - 1) * col)\n}\nexport const hasLeft = (index: number, len: number, row: number, col: number) => {\n  return !(index % col === 0)\n}\nexport const hasRight = (index: number, len: number, row: number, col: number) => {\n  return !((index + 1) % col === 0)\n}\nexport const hasTopLeft = (index: number, len: number, row: number, col: number) => {\n  return hasTop(index, len, row, col) && hasLeft(index - col, len, row, col)\n}\nexport const hasTopRight = (index: number, len: number, row: number, col: number) => {\n  return hasTop(index, len, row, col) && hasRight(index - col, len, row, col)\n}\nexport const hasBottomLeft = (index: number, len: number, row: number, col: number) => {\n  return hasBottom(index, len, row, col) && hasLeft(index + col, len, row, col)\n}\nexport const hasBottomRight = (index: number, len: number, row: number, col: number) => {\n  return hasBottom(index, len, row, col) && hasRight(index + col, len, row, col)\n}","export enum GameStatus {\n  PLAYING,\n  WIN,\n  LOST,\n}","import { Cell } from '../types/Cell'\nimport { getSurroundingCellIndexes } from './get-surrounding-cell-indexes'\n\ninterface Params {\n  cells: Cell[],\n  numOfMines: number,\n  numOfRows: number, \n  numOfCols: number,\n}\nexport function spreadMines(params: Params) {\n  const {\n    cells,\n    numOfMines,\n    numOfRows,\n    numOfCols,\n  } = params\n  let generatedCount = 0\n  let generatedHash: {\n    [key: string]: boolean,\n  } = {}\n  const length = cells.length\n  let result = cells.slice()\n  while(generatedCount < numOfMines) {\n    const r = Math.floor(Math.random() * length)\n    if (r in generatedHash) {\n      // bad luck.. continue\n    } else {\n      result[r].isMine = true\n      const surroundingCellIndexes = getSurroundingCellIndexes({\n        cells: result,\n        mineIndex: r,\n        numOfRows,\n        numOfCols,\n      })\n      result = increaseMineCountForSurroundingCells(result, surroundingCellIndexes)\n      generatedHash[r] = true\n      generatedCount += 1\n    }\n  }\n  return result\n}\n\nfunction increaseMineCountForSurroundingCells(cells: Cell[], surroundingCellIndexes: number[]) {\n  const result = cells.slice()\n  return result.map(cell => {\n    if (surroundingCellIndexes.includes(cell.index)) {\n      // can't be more than 8\n      const added = (cell.numOfMinesAround + 1) <= 8 ? cell.numOfMinesAround + 1 : cell.numOfMinesAround\n      return {\n        ...cell,\n        numOfMinesAround: added as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8,\n      }\n    }\n    return cell\n  })\n}","import { Cell, CellStatus } from '../types/Cell'\nimport { hasBottom, hasBottomLeft, hasBottomRight, hasLeft, hasRight, hasTop, hasTopLeft, hasTopRight } from './get-surrounding-cell-indexes'\n\ninterface CellWithVisited extends Cell {\n  visited: boolean,\n}\n\ninterface Params {\n  cells: Cell[],\n  originCell: Cell,\n  numOfRows: number, \n  numOfCols: number,\n}\nexport function uncoverAllSafeCells(params: Params): Cell[] {\n  const {\n    cells,\n    originCell,\n    numOfRows: row,\n    numOfCols: col,\n  } = params\n  const stack: CellWithVisited[] = [{\n    ...originCell,\n    visited: false,\n  }]\n  const cellsWithVisited = cells.slice().map(cell => {\n    // set the original one uncovered\n    if (cell.index === originCell.index) {\n      return {\n        ...cell,\n        visited: false,\n        status: CellStatus.Uncovered\n      }\n    }\n    return {\n      ...cell,\n      visited: false,\n    }\n  })\n  while (stack.length) {\n    const currentCell = stack[stack.length - 1] // visit the one on top of stack\n    cellsWithVisited[currentCell.index].visited = true\n    stack.splice(stack.length - 1, 1) // pop from stack\n    dfsVisit(currentCell, cellsWithVisited, row, col, stack)\n  }\n  return cellsWithVisited\n}\n\n/* \n  @param stack will be mutated\n*/\nfunction dfsVisit(currentCell: CellWithVisited, cells: CellWithVisited[], row: number, col: number, stack: CellWithVisited[]) {\n  const index = currentCell.index\n  const len = cells.length\n  // a lot, so we do clockwise, top -> top right -> right -> bottom right -> ... -> left -> top left\n  const directions = [\n    {\n      hasDirectionFunction: hasTop,\n      getIndex: (index: number, row: number, col: number) => index - col,\n    },\n    {\n      hasDirectionFunction: hasTopRight,\n      getIndex: (index: number, row: number, col: number) => index - col + 1,\n    },\n    {\n      hasDirectionFunction: hasRight,\n      getIndex: (index: number, row: number, col: number) => index + 1,\n    },\n    {\n      hasDirectionFunction: hasBottomRight,\n      getIndex: (index: number, row: number, col: number) => index + col + 1,\n    },\n    {\n      hasDirectionFunction: hasBottom,\n      getIndex: (index: number, row: number, col: number) => index + col,\n    },\n    {\n      hasDirectionFunction: hasBottomLeft,\n      getIndex: (index: number, row: number, col: number) => index + col - 1,\n    },\n    {\n      hasDirectionFunction: hasLeft,\n      getIndex: (index: number, row: number, col: number) => index - 1,\n    },\n    {\n      hasDirectionFunction: hasTopLeft,\n      getIndex: (index: number, row: number, col: number) => index - col - 1,\n    },\n  ]\n  directions.forEach(({ hasDirectionFunction, getIndex}) => {\n    if (hasDirectionFunction(index, len, row, col)) {\n      const visitingIndex = getIndex(index, row, col)\n      const cell = cells[visitingIndex]\n      cell.status = CellStatus.Uncovered\n      if (!cell.visited && cell.numOfMinesAround === 0) {\n        stack.push(cell)\n      }\n    }\n  })\n}","import { Cell, CellStatus } from '../types/Cell'\n\nexport function checkGameWin(cells: Cell[]) {\n  const isEveryMineFlagged = cells\n    .filter(cell => cell.isMine)\n    .every(cell => cell.status === CellStatus.Flagged)\n  const isEveryNonMineUncovered = cells\n    .filter(cell => !cell.isMine)\n    .every(cell => cell.status === CellStatus.Uncovered)\n\n  return isEveryMineFlagged && isEveryNonMineUncovered\n}","import React, { useCallback, useEffect, useState } from 'react'\nimport './App.css'\nimport { Cell, CellStatus, isCellCovered, isCellFlagged } from './types/Cell'\nimport { BOARD_COLUMNS, BOARD_ROWS, NUMBER_OF_MINES } from './constants/BoardDimensions'\nimport BoardContainerComp from './comps/BoardContainer'\nimport { spreadMines } from './utils/spread-mines'\nimport { uncoverAllSafeCells } from './utils/uncover-all-safe-cells'\nimport { GameStatus } from './types/GameStatus'\nimport { checkGameWin } from './utils/check-game-win'\n\nfunction App() {\n  const [ cells, setCells ] = useState<Cell[]>([])\n  const [ gameStatus, setGameStatus ] = useState<GameStatus>(GameStatus.PLAYING)\n\n  let initialCells: Cell[] = []\n  for (let index = 0; index < BOARD_COLUMNS * BOARD_ROWS; index++) {\n    const cell: Cell = {\n      index,\n      status: CellStatus.Covered,\n      isMine: false,\n      numOfMinesAround: 0,\n    }\n    initialCells.push(cell)\n  }\n  useEffect(() => {\n    gameReset()\n  }, [])\n\n  const gameReset = () => {\n    setGameStatus(GameStatus.PLAYING)\n    setCells(spreadMines({\n      cells: initialCells,\n      numOfMines: NUMBER_OF_MINES,\n      numOfCols: BOARD_COLUMNS,\n      numOfRows: BOARD_ROWS,\n    }))\n  }\n  const handleCellRightClick = (index: number) => {\n    if (gameStatus !== GameStatus.PLAYING) {\n      return\n    }\n    const targetCell = cells[index]\n    if (isCellCovered(targetCell)) {\n      const upcomingCells = [\n        ...cells.slice(0, index),\n        {\n          ...targetCell,\n          status: CellStatus.Flagged,\n        },\n        ...cells.slice(index + 1),\n      ]\n      setCells(upcomingCells)\n      if (checkGameWin(upcomingCells)) {\n        setGameStatus(GameStatus.WIN)\n      }\n    } else if (isCellFlagged(targetCell)) {\n      setCells([\n        ...cells.slice(0, index),\n        {\n          ...targetCell,\n          status: CellStatus.Covered,\n        },\n        ...cells.slice(index + 1),\n      ])\n    }\n  }\n  const handleCellClick = (index: number) => {\n    if (gameStatus !== GameStatus.PLAYING) {\n      return\n    }\n\n    const targetCell = cells[index]\n    const { isMine, numOfMinesAround } = targetCell\n\n    if (isCellCovered(targetCell)) {\n      let upcomingCells: Cell[]\n      if (!isMine && numOfMinesAround === 0) {\n        upcomingCells = uncoverAllSafeCells({\n          cells, \n          originCell: targetCell,\n          numOfCols: BOARD_COLUMNS,\n          numOfRows: BOARD_ROWS,\n        })\n        setCells(upcomingCells)\n      } else {\n        upcomingCells = [\n          ...cells.slice(0, index),\n          {\n            ...targetCell,\n            status: CellStatus.Uncovered,\n          },\n          ...cells.slice(index + 1),\n        ]\n        setCells(upcomingCells)\n      }\n      if (isMine) {\n        setGameStatus(GameStatus.LOST)\n      } else {\n        if (checkGameWin(upcomingCells)) {\n          setGameStatus(GameStatus.WIN)\n        }\n      }\n    }\n  }\n  return (\n    <div className='App'>\n      <div className='main'>\n        <div className='control-bar'>\n          <header>\n            {`Minesweeper!`}\n          </header>\n          { gameStatus === GameStatus.PLAYING ? <div>{NUMBER_OF_MINES - cells.filter(cell => isCellFlagged(cell)).length}</div> : null }\n          { gameStatus === GameStatus.LOST ? <button onClick={gameReset}>{`Game Over.. Restart?`}</button> : null }\n          { gameStatus === GameStatus.WIN ? <button onClick={gameReset}>{`Cong! Restart?`}</button> : null }\n        </div>\n        <BoardContainerComp \n          cells={cells} \n          onCellRightClick={handleCellRightClick}\n          onCellClick={handleCellClick}\n        />\n      </div>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}